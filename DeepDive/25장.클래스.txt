25.1 클래스는 프로토타입의 문법적 설탕인가?

    다른 클래스 기반 언어들과 달리 자바스크립트의 클래스는 함수며 프로토타입 기반 패턴을 사용한다
    => new 연산자의 유뮤, 호이스팅 등 차이점이 존재한다

25.2 클래스 정의

    class 키워드를 사용하여 정의하며, 함수이기에 일급 객체의 특징을 갖는다
    => 몸체에선 constructor(생성자), 프로토타입 메서드, 정적 메서드 총 3가지를 정의할 수 있다

25.3 클래스 호이스팅

    클래스 선언문도 함수 선언문처럼 런타임 이전에 먼저 평가되어 객체를 생성하지만 클래스 정의 이전에 참조할 수 없다(let, const 키워드와 비슷)

25.4 인스턴스 생성

    클래스는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성한다
    기명 함수 표현식처럼 이미 사용된 식별자 이름은 외부 코드에서 접근 불가능하다

25.5 메서드

    (1) constructor
        인스턴스를 생성하고 초기화하기 위한 특수한 메서드다
        => 정확하게 표현하면 메서드로 해석되는 것이 아닌 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다
        => 클래스 내 최대 한 개만 존재해야 하며, 생략하면 암묵적으로 빈 constructor가 정의된다
        => 생성자 함수처럼 return 문을 반드시 생략하자

    (2) 프로토타입 메서드
        객체의 .prototype 프로퍼티에 직접적으로 추가하지 않아도 기본적으로 프로토타입 메서드가 된다
        => 생성자 함수처럼 결국 프로토타입 기반의 객체 생성 메커니즘이다

    (3) 정적 메서드
        인스턴스를 생성하지 않아도 호출할 수 있는 메서드, static 키워드만 붙이면 된다

    (4) 정적 메서드와 프로토타입 메서드의 차이
        1. 각자 자신이 속해 있는 프로토타입 체인이 다르다
        2. 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다
        3. 프로토타입 메서드만 인스턴스 프로퍼티를 참조할 수 있다

        정적 메서드는 클래스를 참조하기에 this 바인딩이 클래스를 가리킨다

    (5) 클래스에서 정의한 메서드의 특징
        1. function 키워드를 생략한 메서드 축약 표현을 사용한다
        2. ,(콤마)가 필요 없다
        3. 암묵적으로 strict mode로 실행된다
        4. 프로퍼티를 열거할 수 없기에 for문 등으로 열거가 불가능하다
        5. non-constructor이기에 new 연산자와 호출할 수 없다

25.6 클래스의 인스턴스 생성 과정

    1. 인스턴스 생성과 this 바인딩
        암묵적을 빈 객체를 만든 뒤 인스턴스의 프로토타입으로 클래스를 가리키게 설정하고 인스턴스에 this가 바인딩된다

    2. 인스턴스 초기화
        constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티를 초기화한다
        만약 constructor가 생략되었다면 이 과정도 생략한다

    3. 인스턴스 반환
        바인딩된 this가 암묵적으로 반환된다

25.7 프로퍼티

    (1) 인스턴스 프로퍼티
        constructor 내부에서 정의해야 클래스가 암묵적으로 생성한 빈 객체에 추가된다
        => 접근 제한자가 없기에 언제나 public하다

    (2) 접근자 프로퍼티
        자체적으론 값이 없으나 다른 프로퍼티의 값을 참조할 때 사용하는 접근자 함수로 구성된 프로퍼티다
        => getter 함수와 setter 함수로 구성되어 있다
        => get 키워드로 getter가 호출되어 프로퍼티를 참조하고 반드시 무언가를 반환
        => set 키워드로 setter가 호출되어 단 하나의 매개변수를 갖고 단 하나의 값을 프로퍼티에 할당한다
        => 기본적으로 프로토타입의 프로퍼티가 된다
    
    (3) 클래스 필드 정의 제안
        클래스 필드: 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어
        => 따라서 자바처럼 클래스 필드를 선언하면 문법 에러가 발생한다(this 바인딩 원리가 다르기 때문)
        => 다만 최신 브라우저나 최신 Node.js에선 미리 구현하긴 했다

    (4) private 필드 정의 제안
        자바스크립트는 캡슐화를 완전하게 지원하진 않는다
        => 인스턴스 프로퍼티는 인스턴스를 통해 언제나 외부에서 참조할 수 있기에 public하다
        => 최신 문법에는 #을 붙여주면 private해진다
        => 반드시 클래스 몸체에 정의해야 하며 접근자 프로퍼티를 통해 간접적으로 접근은 유효하다

    (5) static 필드 정의 제안
        최신 문번에선 static을 붙여주면 된다

25.8 상속에 의한 클래스 확장

    (1) 클래스 상속과 생성자 함수 상속
        프로토타입 체인을 통해 상속받는 것이 아닌 기존 클래스를 상속받아 새로운 클래스를 확장하는 개념이다
        => extends 키워드를 통해 코드의 재사용을 높인다

    (2) extends 키워드
        상속을 통해 클래스를 확장하기 위해 사용하며 상속받을 클래스를 정의한다
        수퍼/베이스/부모 클래스가 서브/파생/자식 클래스에게 상속한다
        => 프로토타입 기반이지만 정적 메서드 또한 상속이 가능하다

    (3) 동적 상속
        extends 키워드는 클래스뿐만 아니라 생성자 함수도 상속받을 수 있지만 반드시 extends 키워드 앞에 클래스가 와야 한다
        => [[Construct]] 내부 메서드를 갖는 함수 객체로 평가되는 모든 표현식을 다 사용 가능하다

    (4) 서브클래스의 constructor
        암묵적으로 빈 constructor가 정의된다

    (5) super 키워드
        1. super 호출
            수퍼클래스의 constructor를 호출하고 서브클래스에게 프로퍼티를 전달한다
            => 서브클래스의 constructor에서만 반드시 super를 호출해야한다

        2. super 참조
            메서드 내에서 참조하면 수퍼클래스의 메서드를 호출할 수 있다
            => 단, ES6의 메서드 축약 표현만이 super 참조가 가능하다

    (6) 상속 클래스의 인스턴스 생성 과정
        1. 서브클래스의 super 호출
            내부 슬롯 [[ConstructKind]]를 통해 수퍼클래스와 서브클래스를 구분한다
            => 서브클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 받아오기에 반드시 super를 호출해줘야한다
        
        2. 수퍼클래스의 인스턴스 생성과 this 바인딩
            인스턴스는 수퍼클래스가 생성하기에 new 연산자로 호출된 함수의 new.target은 서브클래스를 가리킨다
            => prototype 프로퍼티가 가리키는 객체는 서브클래스다

        3. 수퍼클래스의 인스턴스 초기화
            수퍼클래스의 constructor가 실행되어 this에 바인딩된 인스턴스를 초기화한다

        4. 서브클래스 constructor로의 복귀와 this 바인딩
            super가 반환한 인스턴스가 서브클래스의 this에 바인딩되고 그대로 사용된다
            => 이런 이유로 서브클래스의 constructor에서 super를 호출하기 전까지 this를 참조할 수 없다

        5. 서브클래스의 인스턴스 초기화
            이후 수퍼클래스처럼 인스턴스를 초기화한다

        6. 인스턴스 반환
            클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this를 통해 암묵적으로 반환된다

    (7) 표준 빌트인 생성자 함수 확장
        동적 상속(extends 키워드 뒤에 클래스가 아닌 다른 객체가 온다면) 해당 클래스의 인스턴스를 반환(자기가 갖는 인스턴스를 잃는다)
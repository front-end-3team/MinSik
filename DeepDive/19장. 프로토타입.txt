19.1 객체지향 프로그래밍 
    
    객체의 집합으로 프로그램을 표현한다
    => 객체는 속성을 통해 여러 개의 값을 하나의 단위로 구성하여 복합적인 자료구조다
    => 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 것

    추상화: 프로그램에 필요한 속성만 간추려 내어 표현하는 것

19.2 상속과 프로토타입

    어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것
    => 불필요한 중복을 제거, 코드의 재사용
    => 프로토타입을 기반으로 상속을 구현하면 생성된 모든 인스턴스는 상위 객체를 공유 가능

19.3 프로토타입 객체

    모든 객체는 [[Prototype]] 내부 슬롯을 가진다!
    => 객체가 생성되는 방식에 따라 프로토타입이 결정되고 [[Prototype]]에 저장된다

    (1) __proto__접근자 프로퍼티
        모든 객체는 __proto__접근자 프로퍼티를 통해 [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다
        => getter/setter 함수로 프로토타입에 접근한다
        => 상속을 통해 사용된다
        => 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지할 수 있다(단방향 링크드 리스트)
        => 코드 내에서 직접 사용하진 말자

    (2) 함수 객체의 prototype 프로퍼티
        생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다
        => 화살표 함수나 메서드 축약 표현은 프로퍼티도 없고 프로토타입도 생성하지 않는다
        => prototype 프로퍼티나 __proto__접근자 프로퍼티는 동일한 프로토타입을 가리킨다

    (3) 프로토타입의 constructor 프로퍼티와 생성자 함수
        모든 프로토타입은 constructor 프로퍼티를 갖는다

19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

    new 연산자와 함께 생성자 함수를 호출하야 인스턴스를 생성한 객체의 프로토타입과
    리터럴 표기법에 의해 생성된 객체의 프로토타입이 동일하진 않다(큰 차이는 없다)
    => 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재한다!!
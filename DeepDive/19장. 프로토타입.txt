19.1 객체지향 프로그래밍 
    
    객체의 집합으로 프로그램을 표현한다
    => 객체는 속성을 통해 여러 개의 값을 하나의 단위로 구성하여 복합적인 자료구조다
    => 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 것

    추상화: 프로그램에 필요한 속성만 간추려 내어 표현하는 것

19.2 상속과 프로토타입

    어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것
    => 불필요한 중복을 제거, 코드의 재사용
    => 프로토타입을 기반으로 상속을 구현하면 생성된 모든 인스턴스는 상위 객체를 공유 가능

19.3 프로토타입 객체

    모든 객체는 [[Prototype]] 내부 슬롯을 가진다!
    => 객체가 생성되는 방식에 따라 프로토타입이 결정되고 [[Prototype]]에 저장된다

    (1) __proto__접근자 프로퍼티
        모든 객체는 __proto__접근자 프로퍼티를 통해 [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다
        => getter/setter 함수로 프로토타입에 접근한다
        => 상속을 통해 사용된다
        => 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지할 수 있다(단방향 링크드 리스트)
        => 코드 내에서 직접 사용하진 말자

    (2) 함수 객체의 prototype 프로퍼티
        생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다
        => 화살표 함수나 메서드 축약 표현은 프로퍼티도 없고 프로토타입도 생성하지 않는다
        => prototype 프로퍼티나 __proto__접근자 프로퍼티는 동일한 프로토타입을 가리킨다

    (3) 프로토타입의 constructor 프로퍼티와 생성자 함수
        모든 프로토타입은 constructor 프로퍼티를 갖는다

19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

    new 연산자와 함께 생성자 함수를 호출하야 인스턴스를 생성한 객체의 프로토타입과
    리터럴 표기법에 의해 생성된 객체의 프로토타입이 동일하진 않다(큰 차이는 없다)
    => 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재한다!!

19.5 프로토타입의 생성 시점

    모든 객체는 생성자 함수와 연결되어 있다
    => 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다 (언제나 쌍으로 존재한다)

    (1) 사용자 정의 생성자 함수와 프로토타입 생성 시점
        내부 메서드 [[Constructor]]를 갖는 함수는 객체가 생성되는 시점에 프로토타입도 같이 생성된다
        => 생성된 프로토타입의 프로토타입은 항상 Object.prototype이다

    (2) 빌트인 생성자 함수와 프로토타입 생성 시점
        전역 객체가 생성되는 시점에 생성된 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당된다

19.6 객체 생성 방식과 프로토타입의 결정

    객체 생성 방식
    - 객체 리터럴
    - Object 생성자 함수
    - 생성자 함수
    - Object.create 메서드
    - 클래스(ES6)

    (1) 객체 리터럴에 의해 생성된 객체의 프로토타입
        추상 연산 OrdinaryObjectCreate를 호출하여 프로토타입 Object.prototype을 전달한다
        => Object.prototype의 constructor 프로퍼티와 hasOwnProperty 메서드를 자기 것처럼 사용할 수 있다

    (2) Object 생성자 함수에 의해 생성된 객체의 프로토타입
        빈 객체를 생성한 후 추상 연산 OrdinaryObjectCreate이 호출되며, 객체 리터럴과 같은 과정을 수행한다
        차이점이라면, Object 생성자 함수는 빈 객체를 먼저 생성한 후 프로퍼티가 추가된다는 점이다

    (3) 생성자 함수에 의해 생성된 객체의 프로토타입
        위 과정과 비슷하지만 추상 연산 OrdinaryObjectCreate에 전달되는 프로토타입은 
        생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체다
        => 프로토타입 Object.prototype의 프로퍼티 중 constructor만 가져온다!!
        => 이후 일반 객체처럼 프로토타입에 프로퍼티를 추가/삭제할 수 있다

19.7 프로토타입 체인

    자바스크립트는 객체의 프로퍼티에 접근하려 할 때 참조할 프로퍼티가 없다면 스코프 체인처럼
    프로토타입 체인이 존재하여 자신의 상위 요소를 순차적으로 검색한다

    프로토타입 체인의 최상위 객체는 언제나 Object.prototype이다!!
    => 모든 객체가 상속받으며 내부 슬롯의 값은 null이다
    => 프로토타입 체인의 종점을 넘어간다면 undefined를 반환(에러 발생 X)

    스코프 체인이 식별자 검색을 위한 메커니즘이라면,
    프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘이다
    => 두 체인은 독립적이지 않다(함께 동작한다)

19.8 오버라이딩과 프로퍼티 섀도잉

    프로토타입 프로퍼티: 프로토타입이 소유한 프로퍼티
    인스턴스 프로퍼티: 인스턴스가 소유한 프로퍼티

    오버라이딩: 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식

    (오버로딩: 함수 이름이 동일하더라도 매개변수의 타입 또는 개수를 구별하여 따로 호출하는 방식이지만
     자바스크립트는 지원하지 않지만, 단 arguments 객체를 사용하여 구현할 수는 있다)

     오버라이딩이 발생하면 상속 관계에 의해 프로퍼티가 가려지는(덮어씌어지는) 현상을 프로퍼티 섀도잉이라 한다

     하위 객체를 통해 프로퍼티를 변경 또는 삭제는 불가능하다
     => get 액세스는 허용되나 set 액세스는 허용하지 않는다
     => 원시 값을 다룰 때처럼 덮어씌우는 것일뿐 변경이나 삭제가 아니다!!
     => 만약 변경/삭제를 원한다면 프로토타입 체인으로 접근이 아닌 직접 접근해야 한다